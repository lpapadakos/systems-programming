Προγραμματισμός Συστήματος 2019-20
Εργασία 2

Λεωνίδας-Παναγιώτης Παπαδάκος, ΑΜ 1115201700117
================================================================================

Παραδοχές:

[0] Το πρόγραμμα υλοποιεί τη σχεδίαση των δομών όπως παρουσιάζεται στη σελ. 4
της εκφώνησης, με την εξαίρεση ότι τα records των ασθενών δεν είναι σε μία
λίστα, αλλά είναι διαμοιρασμένα σε ένα hashtable που οδηγεί σε λίστες.
Το στοιχείο-κλειδί είναι το recordID.

[1] #define FIELD_SIZE 32: Θεωρώ ότι οι συμβολοσειρές για τα records των ασθενών
(π.χ. Όνομα, Επώνυμο) χωρούν σε 31 bytes (+1 για το NULL byte, στην χειρότερη
περίπτωση).

[2] Ασθενείς με την ίδια ημερομηνία εισαγωγής δημιουργούν duplicates στο tree.

[3] Η συνθήκη που ορίζει απουσία exit_date (ο ασθενής δεν έχει πάρει εξιτήριο)
είναι το να έχει το πρώτο exit_date[0] == '\0'.

[4] Κρούσματα στο διάστημα [date1, date2] θεωρούνται οι εγγραφές ασθενών με
date1 <= entryDate <= date2.

[5] Αν ο αλγόριθμος εισαγωγής countries/diseases βρει κενό σε ένα bucket, δεν
χρειάζεται να κοιτάξει σε σύνδεσμο next καθώς η ύπαρξη κενού αποκλείει την
ύπαρξη επόμενου bucket (Τα στοιχεία εισάγωνται σειριακά).

[6] Χρησιμοποιώ τη συνάρτηση djb2 από τον Dan Bernstein για string hash.
Περισσότερα: http://www.cse.yorku.ca/~oz/hash.html

[7] Η εκφώνηση αναφέρει ότι μπορούμε να υποθέσουμε πως όλοι οι μήνες έχουν 30
μέρες.

[8] Ένας γρήγορος τρόπος να σιγουρευτούμε για τη μοναδικότητα των records είναι
να τα εισάγουμε με αύξοντα αριθμό (Το οποίο είναι και valid recordID).

[9] Το poll() είναι ένα API παρόμοιο με το select() και μου άρεσε το
interface του. Χρησιμοποιείται για την αποδοτική ανάγνωση των αποκρίσεων των
workers.

[10] Περιγραφή Πρωτοκόλλου Επικοινωνίας:
Τα μηνύματα είναι null-terminated strings.
Έχουν header (cmd) και arguments.
(argument delimiter είναι το '\n', end είναι το '\0')

- Ο aggregator γράφει requests στο request pipe, απ'όπου διαβάζει ο worker.
- Ο worker γράφει responses στο response pipe, απ'όπου διαβάζει ο aggregator.

Όταν έχει γράψει την απόκρισή του εξ'ολοκλήρου, ο worker στέλνει το μήνυμα
READY πάνω στο response pipe.

e.g.
REQUEST: (Ανάθεση καταλόγων σε worker)
"/directories\nChina\nGermany\n\0"

(άλλο παράδειγμα: "/searchPatientRecord\n782\0")

example strace: (bufferSize 100)
write(11, "/numPatientAdmissions", 21)  = 21
write(11, "\n", 1)                      = 1
write(11, "EVD", 3)                     = 3
write(11, "\n", 1)                      = 1
write(11, "01-01-0000", 10)             = 10
write(11, "\n", 1)                      = 1
write(11, "01-01-3000", 10)             = 10
write(11, "\n", 1)                      = 1
write(11, "\0", 1)                      = 1

RESPONSE: (1 string ανά αρχείο ημερομηνίας, στο τελος READY)
DD-MM-YYYY
Disease-1
EBOLA
Age range 0-20 years: 2 cases
Age range 21-40 years: 2 cases
Age range 41-60 years: 3 cases
Age range 60+ years: 5 cases

Disease-2
Age range 0-20 years: 1 cases
Age range 21-40 years: 1 cases
Age range 41-60 years: 1 cases
Age range 60+ years: 1 cases

\0<file2>\0READY\0"

[11] Διάβασμα μηνύματος από pipe:
- Διάβασε chunks μεγέθους <= bufferSize μέχρι να συμβεί κάποιο από τα παρακάτω:
	- Το buffer ανακατασκευής μηνυμάτων (struct p_msg) γέμισε.
	- Ο τελευταίος χαρακτήρας που διαβάστηκε είναι (nul), οπότε έχουμε
	  τουλάχιστον ένα ολόκληρο μύνημα στο buffer ανακατασκευής μηνυμάτων.
	- Είμαστε σε non-blocking IO mode, και η read επιστρέφει -1 με errno ==
	  EAGAIN. (Δηλαδή πήγαμε να διαβάσουμε pipe που είναι, για τώρα, κενός)

+------------------------------------------------------------------------------+
|         msg1     (\0)|            msg2        (\0)| msg3 (partial) |  (free) |
+------------------------------------------------------------------------------+
                                                                  pos ^

Ο reader καταναλώνει όσα strings (ολόκληρα μηνύματα) υπάρχουν στο p_msg buffer
και σετάρει το flag msg.consumed. Έτσι η επόμενη msg_read() ξέρει να αξιοποιήσει
εκ νέου το χώρο που καταλαμβανόταν από προηγούμενα strings.

[12] Ο signal handler σετάρει ατομικά το κατάλληλο flag, διακόπτοντας το
blocked system call (ο aggregator περιμένει input απ΄οτο χρήστη, ο worker
περιμένει input από τον aggregator). Μετά το process ελέγχει το flag και το
χειρίζεται όπως αρμόζει η εκφώνηση.

[13] Με τη λήψη του SIGUSR1 ο worker διαβάζει τυχόν νέα αρχεία στους καταλόγους
(τα νέα αρχεία είναι για μεταγενέστερες ημερομηνίες σύμφωνα με το Piazza).
Στέλνει SIGUSR1 στο γονέα για να τον ενημερώσει ότι θα στείλει statistics που
πρέπει να εκτυπωθούν.

[14] Τα requests τα χειρίζονται οι workers. Η δουλειά του aggregator είναι να
μαζέψει την πληροφορία και να την παρουσιάσει στο χρήστη σύμφωνα με το πρότυπο
της εκφώνησης.

[15] Successful request είναι αυτό για το οποίο η handler συνάρτηση θα επιστρέψει
DA_OK (DiseaseAggregator_OK, Russian pun intended), και είναι κοινή πολιτική και
για τον aggregator, και για τους workers. Η "πορεία" προς το DA_OK μπορεί να
ανακοπεί για διάφορους λόγους. Δεν μετριέται το /exit.

[16] Η εκτύπωση των statistics για το αρχείο γίνεται μόνο αν υπήρξε σωστή
εγγραφή στο αρχείο.
