Προγραμματισμός Συστήματος 2019-20
Εργασία 1

Λεωνίδας-Παναγιώτης Παπαδάκος, ΑΜ 1115201700117
================================================================================

Παραδοχές:

[0] Το πρόγραμμα υλοποιεί τη σχεδίαση των δομών όπως παρουσιάζεται στη σελ. 4
της εκφώνησης, με την εξαίρεση ότι τα records των ασθενών δεν είναι σε μία
λίστα, αλλά είναι διαμοιρασμένα σε ένα hashtable που οδηγεί σε λίστες.
Το στοιχείο-κλειδί είναι το recordID.

[1] #define FIELD_SIZE 32: Θεωρώ ότι οι συμβολοσειρές για τα records των ασθενών
(π.χ. Όνομα, Επώνυμο) χωρούν σε 31 bytes (+1 για το NULL byte, στην χειρότερη
περίπτωση).

[2] Ασθενείς με την ίδια ημερομηνία εισαγωγής δημιουργούν duplicates στο tree.

[3] Η συνθήκη που ορίζει απουσία exit_date (ο ασθενής δεν έχει πάρει εξιτήριο)
είναι το να έχει το πρώτο exit_date[0] == '\0'.

[4] Κρούσματα στο διάστημα [date1, date2] θεωρούνται οι εγγραφές ασθενών με
date1 <= entryDate <= date2.

[5] Αν ο αλγόριθμος εισαγωγής countries/diseases βρει κενό σε ένα bucket, δεν
χρειάζεται να κοιτάξει σε σύνδεσμο next καθώς η ύπαρξη κενού αποκλείει την
ύπαρξη επόμενου bucket (Τα στοιχεία εισάγωνται σειριακά).

[6] Χρησιμοποιώ τη συνάρτηση djb2 από τον Dan Bernstein για string hash.
Περισσότερα: http://www.cse.yorku.ca/~oz/hash.html

[7] Η μέθοδος που χρησιμοποιώ για να βρώ το τελευταίο στοιχείο του δυαδικού
σωρού βασίζεται στο γεγονός ότι, αν αριθμίσουμε από τα αριστερά προς τα δεξιά
τους κόμβους του δέντρου για κάθε επίπεδο, η αλληλουχία των bits στο index ενός
κόμβου μας δίνει οδηγίες για το πως να φτάσουμε σε αυτόν από τη ρίζα. Η αρίθμιση
των κόμβων ξεκινά από το 1. Άρα το index του τελευταίου κόμβου ισούται με τον
αριθμό των κόμβων του δέντρου.
Παράδειγμα: 4 = 100. Αγνοούμε πάντα το πρώτο 1. 0 σημαίνει αριστερά, άρα πάμε
αριστερά 2 φορές.
